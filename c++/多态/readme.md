# 多态

## 机制

* 静态联编：对于非虚函数，在编译的时候就确定好要去调用哪一个函数
* 动态联编：对于虚函数，在运行的时候才确定调用哪一个函数。有虚函数的对象里有一个指针，指向虚函数表，调用虚函数时，会根据对象里的指针找到表，从表中取出函数来执行。
```
1. 对象里有指针
	指向虚函数表
2. 通过指针，找到表
	调用虚函数
```
## 差异
* 静态联编效率高，动态联编支持多态

```
fun(T *t);
fun(T &t);
使用指针或引用来使用对象时，才有多态

fun(T t);
传值时，无多态
-----------------------------------------------------------------------
只有类的成员函数才能声明为虚函数
-----------------------------------------------------------------------
静态成员函数不能是虚函数
-----------------------------------------------------------------------
内联函数不能是虚函数
-----------------------------------------------------------------------
构造函数不能是虚函数
-----------------------------------------------------------------------
析构函数一般都声明为虚函数，否则会默认为基类的析构函数
$ ./a.exe
use hand to eat
~Human
use knife to eat
~Human
use chopsticks to eat
~Human

$ ./a.exe
use hand to eat
~Human
use knife to eat
~Englishman
~Human//会有~Human这是因为析构函数本身的特性，先析构自己，再析构基类
use chopsticks to eat
~Chinese
~Human

-----------------------------------------------------------------------
重载：函数参数不同，不可设为虚函数
覆盖：函数参数、返回值相同，可以设为虚函数
-----------------------------------------------------------------------
返回值例外：函数参数相同，但是返回值是当前对象的指针或引用时，也可以设为虚函数
```

1. 使用指针或引用来使用对象时，才有多态
```
fun(T *t);
fun(T &t);
```

2. 传值时，无多态
```
fun(T t);
```
3. 只有类的成员函数才能声明为虚函数

4. 静态成员函数不能是虚函数

5. 内联函数不能是虚函数

6. 构造函数不能是虚函数

7. 析构函数一般都声明为虚函数，否则会默认为基类的析构函数
```
$ ./a.exe
use hand to eat
~Human
use knife to eat
~Human
use chopsticks to eat
~Human

$ ./a.exe
use hand to eat
~Human
use knife to eat
~Englishman
~Human//会有~Human这是因为析构函数本身的特性，先析构自己，再析构基类
use chopsticks to eat
~Chinese
~Human
```
8. 重载：函数参数不同，不可设为虚函数
9. 覆盖：函数参数、返回值相同，可以设为虚函数
10. 返回值例外：函数参数相同，但是返回值是当前对象的指针或引用时，也可以设为虚函数





![动态联编](%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96.png)

* 未使用virtual
```
$ ./a.exe
use hand to eat
use hand to eat
use hand to eat
sizeof(Human) = 4
sizeof(Englishman) = 4
sizeof(Chinese) = 4
```
* 使用virtual（多出来的字节便是这个指针）
```
$ ./a.exe
use hand to eat
use knife to eat
use chopsticks to eat
sizeof(Human) = 8
sizeof(Englishman) = 8
sizeof(Chinese) = 8
```

