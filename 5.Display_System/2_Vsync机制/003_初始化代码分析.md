# 003_初始化代码分析

标签（空格分隔）： Display Vsync

---

## 5个线程：都位于SurfaceFlinger进程中--Main_surfaceflinger.cpp
1. 产生`Vsync`信号的SW `VsyncThread`线程（如果没有HW的话）
2. 虚拟化Vsync信号的`DispSyncThread`线程
3. 被拆分出来的`Vsync-sf`与`Vsync-app`会被`EventThread for sf`与`EventThread for app`两个线程所捕捉
4. `SurfaceFlinger`线程

## 5个线程的创建
### `SurfaceFlinger` 线程
```
main_surfaceflinger.cpp

int main(int, char**) {
    // When SF is launched in its own process, limit the number of
    // binder threads to 4.
    ProcessState::self()->setThreadPoolMaxThreadCount(4);

    // start the thread pool
    sp<ProcessState> ps(ProcessState::self());
    ps->startThreadPool();

    // instantiate surfaceflinger
    //注意new的时候会初始化很多东西，比如DispSyncThread线程
    //此外sp，strong pointer,记得会有onFirstRef()调用
    sp<SurfaceFlinger> flinger = new SurfaceFlinger();

...
    // initialize before clients can connect
    //初始化会初始另外几个线程
    flinger->init();

    // publish surface flinger
    sp<IServiceManager> sm(defaultServiceManager());
    sm->addService(String16(SurfaceFlinger::getServiceName()), flinger, false);

    // run in this thread，这就是最后的SurfaceFlinger线程
    //进入查看它是个死循环，在waitevent，它与EventThread通过一个文件句柄传输数据
    flinger->run();

    return 0;
}

//SurfaceFlinger.cpp / .h
有一个 DispSync 成员对象，就是下面的DispSyncThread

```

### `DispSyncThread` 线程
该线程其实是在`SurfaceFlinger`线程创建`SurfaceFlinger`对象的时候创建的，该线程之后会被分成`Vsync-sf`与`Vsync-app`
```
DispSync::DispSync() :
        mRefreshSkipCount(0),
        mThread(new DispSyncThread()) {

    mThread->run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);

    reset();
    beginResync();

    if (kTraceDetailedInfo) {
        // If we're not getting present fences then the ZeroPhaseTracer
        // would prevent HW vsync event from ever being turned off.
        // Even if we're just ignoring the fences, the zero-phase tracing is
        // not needed because any time there is an event registered we will
        // turn on the HW vsync events.
        if (!kIgnorePresentFences) {
            addEventListener(0, new ZeroPhaseTracer());
        }
    }
}

```

### `VsyncThread`, `Vsync-sf` & `Vsync-app` 线程
```
HWComposer::HWComposer(
        const sp<SurfaceFlinger>& flinger,
        EventHandler& handler)
    : mFlinger(flinger),
      mFbDev(0), mHwc(0), mNumDisplays(1),
      mCBContext(new cb_context),
      mEventHandler(handler),
      mDebugForceFakeVSync(false)
{
...
//  S/W 产生 VsyncThread，注意其onFirstRed()
if (needVSyncThread) {
        // we don't have VSYNC support, we need to fake it
        mVSyncThread = new VSyncThread(*this);
    }

...
}
```
```
SurfaceFlinger.cpp
void SurfaceFlinger::init() {
...
//会产生Vsync信号——根据H/W or S/W,即VsyncThread
    mHwc = new HWComposer(this,
            *static_cast<HWComposer::EventHandler *>(this));
...
 // start the EventThread
 //参数除了名字有差别，offset也有差别
    sp<VSyncSource> vsyncSrc = new DispSyncSource(&mPrimaryDispSync,
            vsyncPhaseOffsetNs, true, "app");
    mEventThread = new EventThread(vsyncSrc);
    sp<VSyncSource> sfVsyncSrc = new DispSyncSource(&mPrimaryDispSync,
            sfVsyncPhaseOffsetNs, true, "sf");
    mSFEventThread = new EventThread(sfVsyncSrc);
...

}
```




